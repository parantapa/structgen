#include <stdlib.h>
#include <string.h>
#include <inttypes.h>

#include "{{ spec.module }}.h"

{% for table in spec.tables.values() %}
int {{ table.name }}_malloc(struct {{ table.name }} *obj, size_t capacity) {
    obj->size = 0 ;
    obj->capacity = capacity ;

    {% for column in table.columns %}
    {% if column.type_ is scalar %}
    obj->{{ column.name }} = malloc(sizeof({{ column.type_ | c_type }}) * capacity) ;
    if (!obj->{{ column.name }}) {
        return 1;
    }
    {% else %}
    for (size_t i = 0; i < {{ column.type_.length_constant }}; i++) {
        obj->{{ column.name }}[i] = malloc(sizeof({{ column.type_ | c_type }}) * capacity);
        if (!obj->{{ column.name }}[i]) {
            return 1;
        }
    }
    {% endif %}
    {% endfor %}

    return 0;
}

void {{ table.name }}_free(struct {{ table.name }} *obj) {
    {% for column in table.columns %}
    {% if column.type_ is scalar %}
    free(obj->{{ column.name }}) ;
    {% else %}
    for (size_t i = 0; i < {{ column.type_.length_constant }}; i++) {
         free(obj->{{ column.name }}[i]) ;
    }
    {% endif %}
    {% endfor %}

    obj->size = 0 ;
    obj->capacity = 0 ;
}

void {{ table.name }}_zero(struct {{ table.name }} *obj) {
    obj->size = 0 ;

    {% for column in table.columns %}
    {% if column.type_ is scalar %}
    memset(obj->{{ column.name }}, 0, sizeof({{ column.type_ | c_type }}) * obj->capacity) ;
    {% else %}
    for (size_t i = 0; i < {{ column.type_.length_constant }}; i++) {
        memset(obj->{{ column.name }}[i], 0, sizeof({{ column.type_ | c_type }}) * obj->capacity);
    }
    {% endif %}
    {% endfor %}
}

int {{ table.name }}_write_csv(struct {{ table.name }} *obj, FILE *stream) {
    {% set hdr, fmt, cols = printf_fmt("obj", "i", table, spec) %}
    int ret;

    ret = fprintf(stream, "{{ hdr }}\n");
    if (ret < 0) {
        return 1;
    }
    for (size_t i = 0; i < obj->size; i++) {
        ret = fprintf(stream, {{ fmt }} "\n", {{ cols }});
        if (ret < 0) {
            return 1;
        }
    }

    return 0;
}

int {{ table.name }}_read_csv(struct {{ table.name }} *obj, FILE *stream) {
    {% set fmt, cols, n_cols = scanf_fmt("obj", "i", table, spec) %}
    int ret;

    obj->size = 0;

    /* skip the first header line */
    ret = fscanf(stream, "%*[^\n]\n");
    if (ret == EOF) {
        return 1;
    }

    while (obj->size < obj->capacity) {
        size_t i = obj->size;

        ret = fscanf(stream, {{ fmt }} "\n", {{ cols }});
        if (ret == {{ n_cols }}) {
            obj->size += 1;
        } else {
            return 0;
        }
    }

    return 0;
}

int {{ table.name }}_print_csv(struct {{ table.name }} *obj) {
    return {{ table.name }}_write_csv(obj, stdout);
}

int {{ table.name }}_scan_csv(struct {{ table.name }} *obj) {
    return {{ table.name }}_read_csv(obj, stdin);
}

{% endfor %}
